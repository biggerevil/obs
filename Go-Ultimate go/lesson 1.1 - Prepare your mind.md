#### Somewhere Along The Line
* We became impressed with programs that contain large amounts of
code. (1)
* We strived to create large abstractions in our code base. (2)
* We forgot that the hardware is the platform. (3)
* We lost the understanding that every decision comes with a cost. (4)

Одна из вещей, которую Go пытается достичь - **уменьшение объёма кода** (количества строк, например), который нам нужен для какого-либо проекта. Чтобы было легче управлять кодом, поддерживать его.

В Go мы хотим использовать тонкий (thin) слой абстракций, которые при этом точные (precise). И это помогает с читаемостью, с поддерживанием.

Если нам важна производительность (perfomance), то нам важна и аппаратная часть (hardware). Всё-таки это аппаратная часть исполняет инструкции. И модель Go (Go's model) - это аппаратная часть, а не виртуальная машина. *И это, если я правильно перевожу - повлияет на то, как мы читаем и пишем код, и это будет не так, как мы писали раньше (хотя я не уверен, что прям такая разница будет).*
И в этом курсе мы будем говорить о **[mechanical sympathy](https://algodma.wordpress.com/2019/11/28/%D0%BF%D0%BE%D1%87%D1%83%D0%B2%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D1%83/)**, то есть о понимании, как всё работает под капотом, чтобы мы могли писать лучший код.

На протяжении всего курса мы также будем говорить о:
Для Билла Кеннеди, engineering - это **понимание стоимости принимаемых решений**.
	"
Если вы в самом деле не понимаете стоимость своих решений - вы не программируете, вы хакаете, то есть не понимаете, что вы делаете, и просто пытаетесь заставить что-то работать. 
И это нормально - нам нередко нужна делать прототип чего-либо и просто хакать вещи - проблема не в самом хакинге, а в том, что когда мы прекращаем хакать, мы НЕ возвращаемся назад, и НЕ думаем о том, какие инженерную стоимость несут с собой наши решения.
	"
Билл Кеннеди большой сторонник того, чтобы сделать прототип вещи, возможно, хакнуть их, но НЕ закончить на этом - это только самое начало в нашем пути на построении production level software.