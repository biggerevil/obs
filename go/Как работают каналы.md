Взято [отсюда](https://levelup.gitconnected.com/how-does-golang-channel-works-6d66acd54753).

Канал - это *вещь* для коммуникации между горутинами.

Когда мы исполняем код:
```go
ch := make(chan int, 3)
```
Мы создаём канал с буфером, который может содержать в себе 3 значения типа int.

Под катопом, функция `make` аллоцирует структуру `hchan` на куче и возвращает указатель на неё.

### Ожидание из буф. и небуф. каналов
Просто чтобы напомнить, как это работает:
* В случае НЕбуферизованного канала main-горутина останавливается и передаёт исполнение другой горутине.
* В случае БУФеризированного канала main-горутина продолжает исполнение.

```go
package main

import (
        "fmt"
        "time"
)

func greet(c chan string, typeOfChan string) {
        fmt.Println("Before waiting in", typeOfChan)
        // Здесь мы подождём 3 секунды - просто чтобы остановка была заметной
        time.Sleep(3 * time.Second)
        fmt.Println("After waiting in", typeOfChan)
        fmt.Println("Hello " + <-c + "!")
}

func main() {
        fmt.Println("main() started")

        // Здесь код остановится на 2 секунды
        notBuffered := make(chan string)
        go greet(notBuffered, "NOT buffered")
        notBuffered <- "John"

        // А здесь код не остановится
        buffered := make(chan string, 2)
        go greet(buffered, "Buffered")
        buffered <- "Steven"
        // Здесь мы ждём 1 секунду по 2 причинам:
        // 1. Если не ждать, то у нас быстрее закончится main-горутина, чем эта вызванная,
        // то есть ждём, чтобы увидеть просто вывод из нашей горутины.
        // 2. И нам важно, что здесь, в main-горутине, мы ждём МЕНЬШЕ, чем в нашей горутине
        time.Sleep(1 * time.Second)

        fmt.Println("main() stopped")
}


/*

Вывод программы:

main() started
Before waiting in NOT buffered
After waiting in NOT buffered
Hello John!
Before waiting in Buffered
main() stopped

*/
```