**Кратко:** Это как обычная очередь на слайсах, только эффективнее по памяти.

Причём тут очередь на слайсах? У очереди в Go может быть как минимум три реализации: на слайсах, на linked list, и кольцевая очередь.
* Очередь на слайсах неприятна тем, что скорее всего для `Push` мы используем `queue.slice.append`, то есть добавляем просто в конец слайса, а для `Pop` мы делаем `elem := queue.slice[0]` *(то есть просто берём первый элемент)*  `queue.slice = queue[1:]` *(то есть просто в новом слайсе будут все элементы, кроме первого)*, то есть из-за `queue[1:]` мы просто теряем память в начале, она *автоматически* **НЕ** переиспользуется (в отличие от кольцевой очереди).
* Очередь на linked list неприятна тем, что она в принципе немного медленнее и использует больше памяти из-за хранения links. Зато мы, конечно, можем добавлять и удалять элементы посреди очереди, не двигая при этом в памяти соседние элементы, но такое не всегда это нужно.
* Кольцевая очередь предлагает нам эффективность использования слайсов без таких потерь по памяти. Меньше allocations -> лучше performance (меньше allocations как минимум по сравнению с очередью на слайсах).

Кольцевой буфер - структура данных, которая использует буфер (например, массив) фиксированного размера, причём конец и начало этого буфера будто "соединены" (это нередко изображают как кольцо, поэтому такое название).

В кольцевой очереди используются 2 индекса - индекс чтения и индекс записи:
* Индекс чтения показывает индекс элемента, который прочитан и удалён, это же очередь при попытке `Dequeue`.
* Индекс записи показывает индекс элемента, куда будет записан новый элемент при попытке `Enqueue`.

Рассмотрим на примере, как это работает:
1. Буфер из 4 элементов (`bufferCapacity = 4`). Обозначим индекс чтения как ri, а индекс записи как wi. В начале они оба равны 0. Причём важно отметить про то, как понять, что очередь пуста, что в ней нет элементов (или как минимум нет ещё НЕсчитанных элеметов):
	1. ПЕРВЫЙ ПОДХОД: Мы храним какую-то отдельную переменню (например, `elements := 0`), которую увеличиваем каждый раз, когда `Enqueue`, и уменьшаем каждый раз, когда `Dequeue`.
	2. ВТОРОЙ ПОДХОД: Или просто считать, что поскольку ri = rw = 0, то очередь пуста (с таким подходом возникают особенности в дальнейшем, когда очереть почти заполнена).
2. Добавляем один элемент -> wi = 1, ri = 0 (ri = 0, поскольку мы ещё не считывали из очереди).
3. Добавляем ещё 2 элемента -> wi = 3, ri = 0
4. Хотим добавить ещё один элемент, и у нас возникает проблема. Мы либо добавляем, и получаем ri = rw (= 0 в данном случае). Мы по идее в такой ситуации решаем, что очередь пуста, но на самом-то деле в нашем примере она заполнена элементами (которые мы вот только что добавили). Поэтому у нас есть два варианта, как поступать в такой ситуации:
	1. ПЕРВЫЙ ПОДХОД: Если для отслеживания заполненности буфера мы использоуем подход с отдельной переменной, обозначающей число элементов (`elements := 0`), то мы просто добавляем элемент и не паримся.
	2. ВТОРОЙ ПОДХОД: ПЕРЕД каждой попыткой записи проверять, станет ли wi равен ri, причём мы делаем не просто `(wi +1) == ri`, а `(wi + 1) % bufferCapacity == ri` *(если мы не сделаем `% bufferCapacity`, то у нас индекс выйдет за границы буфера)*. Если wi станет равен ri, то мы просто НЕ добавляем элемент. `//TODO: Тогда, по идее, мы теряем один элемент буфера, но мы справляемся с проверкой на переполнение без дополнительной переменной. Я не уверен, что это так, поэтому лучше спросить кого-либо более опытного насчёт этого.`

Пример реализации на C (**без проверки на Full итд**, которая по-хорошему полезна, чтобы не терять случайно данные):
```c
enum {N = 3};
int buf[N];     // N elements circular buffer
int end = 0;    // write index
int start = 0;  // read index

void put(int item) {
  buf[end++] = item;
  end %= N;
}

int get() {
  int item = buf[start++];
  start %= N;
  return item;
}
```